// Code generated by git.sr.ht/~nelsam/hel. DO NOT EDIT.
//
// This file contains mocks generated by hel. Do not edit this code by
// hand unless you *really* know what you're doing. Expect any changes
// made manually to be overwritten the next time hel regenerates this
// file.

package authprovider_test

import (
	context "context"
	"io"
	"time"

	"git.sr.ht/~nelsam/hel/vegr"
	"github.com/moby/buildkit/session/auth"
)

type mockOS struct {
	t          vegr.T
	timeout    time.Duration
	OpenCalled chan bool
	OpenInput  struct {
		Arg0 chan string
	}
	OpenOutput struct {
		Ret0 chan io.ReadCloser
		Ret1 chan error
	}
	GetenvCalled chan bool
	GetenvInput  struct {
		Arg0 chan string
	}
	GetenvOutput struct {
		Ret0 chan string
	}
}

func newMockOS(t vegr.T, timeout time.Duration) *mockOS {
	m := &mockOS{t: t, timeout: timeout}
	m.OpenCalled = make(chan bool, 100)
	m.OpenInput.Arg0 = make(chan string, 100)
	m.OpenOutput.Ret0 = make(chan io.ReadCloser, 100)
	m.OpenOutput.Ret1 = make(chan error, 100)
	m.GetenvCalled = make(chan bool, 100)
	m.GetenvInput.Arg0 = make(chan string, 100)
	m.GetenvOutput.Ret0 = make(chan string, 100)
	return m
}
func (m *mockOS) Open(arg0 string) (ret0 io.ReadCloser, ret1 error) {
	m.t.Helper()
	m.OpenCalled <- true
	m.OpenInput.Arg0 <- arg0
	vegr.PopulateReturns(m.t, "Open", m.timeout, m.OpenOutput, &ret0, &ret1)
	return ret0, ret1
}
func (m *mockOS) Getenv(arg0 string) (ret0 string) {
	m.t.Helper()
	m.GetenvCalled <- true
	m.GetenvInput.Arg0 <- arg0
	vegr.PopulateReturns(m.t, "Getenv", m.timeout, m.GetenvOutput, &ret0)
	return ret0
}

type mockAuthServer struct {
	t                 vegr.T
	timeout           time.Duration
	CredentialsCalled chan bool
	CredentialsInput  struct {
		Arg0 chan context.Context
		Arg1 chan *auth.CredentialsRequest
	}
	CredentialsOutput struct {
		Ret0 chan *auth.CredentialsResponse
		Ret1 chan error
	}
	FetchTokenCalled chan bool
	FetchTokenInput  struct {
		Arg0 chan context.Context
		Arg1 chan *auth.FetchTokenRequest
	}
	FetchTokenOutput struct {
		Ret0 chan *auth.FetchTokenResponse
		Ret1 chan error
	}
	GetTokenAuthorityCalled chan bool
	GetTokenAuthorityInput  struct {
		Arg0 chan context.Context
		Arg1 chan *auth.GetTokenAuthorityRequest
	}
	GetTokenAuthorityOutput struct {
		Ret0 chan *auth.GetTokenAuthorityResponse
		Ret1 chan error
	}
	VerifyTokenAuthorityCalled chan bool
	VerifyTokenAuthorityInput  struct {
		Arg0 chan context.Context
		Arg1 chan *auth.VerifyTokenAuthorityRequest
	}
	VerifyTokenAuthorityOutput struct {
		Ret0 chan *auth.VerifyTokenAuthorityResponse
		Ret1 chan error
	}
}

func newMockAuthServer(t vegr.T, timeout time.Duration) *mockAuthServer {
	m := &mockAuthServer{t: t, timeout: timeout}
	m.CredentialsCalled = make(chan bool, 100)
	m.CredentialsInput.Arg0 = make(chan context.Context, 100)
	m.CredentialsInput.Arg1 = make(chan *auth.CredentialsRequest, 100)
	m.CredentialsOutput.Ret0 = make(chan *auth.CredentialsResponse, 100)
	m.CredentialsOutput.Ret1 = make(chan error, 100)
	m.FetchTokenCalled = make(chan bool, 100)
	m.FetchTokenInput.Arg0 = make(chan context.Context, 100)
	m.FetchTokenInput.Arg1 = make(chan *auth.FetchTokenRequest, 100)
	m.FetchTokenOutput.Ret0 = make(chan *auth.FetchTokenResponse, 100)
	m.FetchTokenOutput.Ret1 = make(chan error, 100)
	m.GetTokenAuthorityCalled = make(chan bool, 100)
	m.GetTokenAuthorityInput.Arg0 = make(chan context.Context, 100)
	m.GetTokenAuthorityInput.Arg1 = make(chan *auth.GetTokenAuthorityRequest, 100)
	m.GetTokenAuthorityOutput.Ret0 = make(chan *auth.GetTokenAuthorityResponse, 100)
	m.GetTokenAuthorityOutput.Ret1 = make(chan error, 100)
	m.VerifyTokenAuthorityCalled = make(chan bool, 100)
	m.VerifyTokenAuthorityInput.Arg0 = make(chan context.Context, 100)
	m.VerifyTokenAuthorityInput.Arg1 = make(chan *auth.VerifyTokenAuthorityRequest, 100)
	m.VerifyTokenAuthorityOutput.Ret0 = make(chan *auth.VerifyTokenAuthorityResponse, 100)
	m.VerifyTokenAuthorityOutput.Ret1 = make(chan error, 100)
	return m
}
func (m *mockAuthServer) Credentials(arg0 context.Context, arg1 *auth.CredentialsRequest) (ret0 *auth.CredentialsResponse, ret1 error) {
	m.t.Helper()
	m.CredentialsCalled <- true
	m.CredentialsInput.Arg0 <- arg0
	m.CredentialsInput.Arg1 <- arg1
	vegr.PopulateReturns(m.t, "Credentials", m.timeout, m.CredentialsOutput, &ret0, &ret1)
	return ret0, ret1
}
func (m *mockAuthServer) FetchToken(arg0 context.Context, arg1 *auth.FetchTokenRequest) (ret0 *auth.FetchTokenResponse, ret1 error) {
	m.t.Helper()
	m.FetchTokenCalled <- true
	m.FetchTokenInput.Arg0 <- arg0
	m.FetchTokenInput.Arg1 <- arg1
	vegr.PopulateReturns(m.t, "FetchToken", m.timeout, m.FetchTokenOutput, &ret0, &ret1)
	return ret0, ret1
}
func (m *mockAuthServer) GetTokenAuthority(arg0 context.Context, arg1 *auth.GetTokenAuthorityRequest) (ret0 *auth.GetTokenAuthorityResponse, ret1 error) {
	m.t.Helper()
	m.GetTokenAuthorityCalled <- true
	m.GetTokenAuthorityInput.Arg0 <- arg0
	m.GetTokenAuthorityInput.Arg1 <- arg1
	vegr.PopulateReturns(m.t, "GetTokenAuthority", m.timeout, m.GetTokenAuthorityOutput, &ret0, &ret1)
	return ret0, ret1
}
func (m *mockAuthServer) VerifyTokenAuthority(arg0 context.Context, arg1 *auth.VerifyTokenAuthorityRequest) (ret0 *auth.VerifyTokenAuthorityResponse, ret1 error) {
	m.t.Helper()
	m.VerifyTokenAuthorityCalled <- true
	m.VerifyTokenAuthorityInput.Arg0 <- arg0
	m.VerifyTokenAuthorityInput.Arg1 <- arg1
	vegr.PopulateReturns(m.t, "VerifyTokenAuthority", m.timeout, m.VerifyTokenAuthorityOutput, &ret0, &ret1)
	return ret0, ret1
}

type mockContext struct {
	t              vegr.T
	timeout        time.Duration
	DeadlineCalled chan bool
	DeadlineOutput struct {
		Deadline chan time.Time
		Ok       chan bool
	}
	DoneCalled chan bool
	DoneOutput struct {
		Ret0 chan (<-chan struct{})
	}
	ErrCalled chan bool
	ErrOutput struct {
		Ret0 chan error
	}
	ValueCalled chan bool
	ValueInput  struct {
		Key chan any
	}
	ValueOutput struct {
		Ret0 chan any
	}
}

func newMockContext(t vegr.T, timeout time.Duration) *mockContext {
	m := &mockContext{t: t, timeout: timeout}
	m.DeadlineCalled = make(chan bool, 100)
	m.DeadlineOutput.Deadline = make(chan time.Time, 100)
	m.DeadlineOutput.Ok = make(chan bool, 100)
	m.DoneCalled = make(chan bool, 100)
	m.DoneOutput.Ret0 = make(chan (<-chan struct{}), 100)
	m.ErrCalled = make(chan bool, 100)
	m.ErrOutput.Ret0 = make(chan error, 100)
	m.ValueCalled = make(chan bool, 100)
	m.ValueInput.Key = make(chan any, 100)
	m.ValueOutput.Ret0 = make(chan any, 100)
	return m
}
func (m *mockContext) Deadline() (deadline time.Time, ok bool) {
	m.t.Helper()
	m.DeadlineCalled <- true
	vegr.PopulateReturns(m.t, "Deadline", m.timeout, m.DeadlineOutput, &deadline, &ok)
	return deadline, ok
}
func (m *mockContext) Done() (ret0 <-chan struct{}) {
	m.t.Helper()
	m.DoneCalled <- true
	vegr.PopulateReturns(m.t, "Done", m.timeout, m.DoneOutput, &ret0)
	return ret0
}
func (m *mockContext) Err() (ret0 error) {
	m.t.Helper()
	m.ErrCalled <- true
	vegr.PopulateReturns(m.t, "Err", m.timeout, m.ErrOutput, &ret0)
	return ret0
}
func (m *mockContext) Value(key any) (ret0 any) {
	m.t.Helper()
	m.ValueCalled <- true
	m.ValueInput.Key <- key
	vegr.PopulateReturns(m.t, "Value", m.timeout, m.ValueOutput, &ret0)
	return ret0
}

type mockReadCloser struct {
	t          vegr.T
	timeout    time.Duration
	ReadCalled chan bool
	ReadInput  struct {
		P chan []byte
	}
	ReadOutput struct {
		N   chan int
		Err chan error
	}
	CloseCalled chan bool
	CloseOutput struct {
		Ret0 chan error
	}
}

func newMockReadCloser(t vegr.T, timeout time.Duration) *mockReadCloser {
	m := &mockReadCloser{t: t, timeout: timeout}
	m.ReadCalled = make(chan bool, 100)
	m.ReadInput.P = make(chan []byte, 100)
	m.ReadOutput.N = make(chan int, 100)
	m.ReadOutput.Err = make(chan error, 100)
	m.CloseCalled = make(chan bool, 100)
	m.CloseOutput.Ret0 = make(chan error, 100)
	return m
}
func (m *mockReadCloser) Read(p []byte) (n int, err error) {
	m.t.Helper()
	m.ReadCalled <- true
	m.ReadInput.P <- p
	vegr.PopulateReturns(m.t, "Read", m.timeout, m.ReadOutput, &n, &err)
	return n, err
}
func (m *mockReadCloser) Close() (ret0 error) {
	m.t.Helper()
	m.CloseCalled <- true
	vegr.PopulateReturns(m.t, "Close", m.timeout, m.CloseOutput, &ret0)
	return ret0
}

type mockWriter struct {
	t           vegr.T
	timeout     time.Duration
	WriteCalled chan bool
	WriteInput  struct {
		P chan []byte
	}
	WriteOutput struct {
		N   chan int
		Err chan error
	}
}

func newMockWriter(t vegr.T, timeout time.Duration) *mockWriter {
	m := &mockWriter{t: t, timeout: timeout}
	m.WriteCalled = make(chan bool, 100)
	m.WriteInput.P = make(chan []byte, 100)
	m.WriteOutput.N = make(chan int, 100)
	m.WriteOutput.Err = make(chan error, 100)
	return m
}
func (m *mockWriter) Write(p []byte) (n int, err error) {
	m.t.Helper()
	m.WriteCalled <- true
	m.WriteInput.P <- p
	vegr.PopulateReturns(m.t, "Write", m.timeout, m.WriteOutput, &n, &err)
	return n, err
}
